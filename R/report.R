# Handle report generation and plotting.  No real processing should happen here.

# TODO support some kind of "pagination" across loci to handle cases with many
# loci.

# Tables ------------------------------------------------------------------

#' Create genotype summary table
#'
#' Report the genotypes present in a processed dataset, converting sequences to
#' short names with optional custom naming.  If custom names are not given or
#' names for sequences are not present in the custom names, a name is
#' autogenerated from the sequence length and a truncated hash.
#'
#' @param results_summary data frame as produced by \code{analyze.dataset}.
#' @param allele.names optional data frame of custom allele names.  If present
#'   the columns "Sequence" and "Name" will be used to map exact sequences to
#'   custom names.
#' @param hash.len number of characters of the sequence has to include when
#'   auto-generating allele names.  If set to zero the hash suffix is not
#'   included.
#' @param ... additional arguments to \code{summarize.genotypes}.
#'
#' @return data frame showing summary of genotypes.
#'
#' @export
report.genotypes <- function(results_summary,
                             allele.names=NULL,
                             hash.len=6,
                             ...) {
  tbl <- summarize.genotypes(results_summary, ...)
  # Name each entry in the table with either a custom or auto-generated short
  # name.
  make.allele_name <- function(data) {
    if (is.character(data)) {
      if(hash.len > 0) {
        paste(nchar(data),
              substr(openssl::md5(tbl[i, j]), 1, 6),
              sep = "-")
      } else {
        nchar(data)
      }
    } else {
      data
    }
  }
  for (j in 3:ncol(tbl)) {
    for (i in 1:nrow(tbl)) {
      if(is.na(tbl[i, j]))
        next
      row <- match(tbl[i, j], allele.names[, "Seq"])
      n <- as.character(allele.names[row, "Name"])
      if (is.na(n) || length(n) == 0)
        n <- make.allele_name(tbl[i, j])
      tbl[i, j] <- n
    }
  }
  # If we have no replicates drop that column
  if (all(is.na(tbl$Replicate)))
    tbl <- tbl[, -2]
  # Blank out NA values
  tbl[is.na(tbl)] <- ''
  tbl
}

report.attribute <- function(dataset.summary, attrib, ...) {
  tbl <- summarize.attribute(dataset.summary, attrib, ...)
  # If we have no replicates drop that column
  if (all(is.na(tbl$Replicate)))
    tbl <- tbl[, -2]
  tbl
}


# Plots -------------------------------------------------------------------

#' Plot histogram of STR sample
#'
#' Given a processed STR sample, plot a histogram of counts per sequence length.
#'
#' @param samp data frame of dereplicated sequences.
#' @param stacked should bars be stacked together to add up to the total count
#'   for each length?  Otherwise they will be overlaid, so each bar height only
#'   corresponds to the count for that exact sequence.
#' @param main title of the plot.
#' @param locus.name name of the locus to match alleles for.  If unspecified the
#'   locus with the highest matched counts will be used.
#' @param sample.summary summary data frame as prepared by
#'   \code{summarize.sample}
#'
#' @export
#' @importFrom magrittr "%>%"
histogram <- function(samp,
                      stacked=TRUE,
                      main=NULL,
                      locus.name=NULL,
                      sample.summary=NULL) {
  col.unlabeled   <- "#DDDDDD" # The non-locus sequences
  # Locus-labeled sequences
  col.labeled     <- "#999999"
  border.labled   <- "#000000"
  # Locus-labeled and matching all allele conditions
  #col.filtered    <- "#FF6666"
  col.filtered    <- "#FFDDDD"
  border.filtered <- "#990000"
  # Sequences matching alleles in sample.summary
  col.allele      <- "#FF0000"
  border.allele   <- "#FF0000"
  lwd <- 5

  if (missing(locus.name)) {
    cts <- with(samp, {
      subset(samp, MatchingLocus != "") %>%
        dplyr::group_by(MatchingLocus) %>%
        dplyr::summarize(Count=sum(Count))
    })
    cts <- cts[order(cts$Count, decreasing = T), ]
    locus.name <- as.character(cts[[1, 'MatchingLocus']])
  }

  # TODO:
  #   support for showing stutter
  #   locus-specific options?
  #   un-stacked version
  #      show threshold

  if (stacked) {
    if (missing(main))
      main <- "Histogram of Sequence Lengths"
    # total counts at each length
    heights <- with(samp, {
        samp %>%
        dplyr::group_by(Length) %>%
        dplyr::summarize(TotalCount = sum(Count))
      })
    # Total ranges for stacked counts
    xlim <- range(heights$Length)
    ylim <- range(heights$TotalCount)
    heights.loci <- with(samp, {
      samp %>%
      subset(MatchingLocus != "") %>%
      dplyr::group_by(Length) %>%
      dplyr::summarize(TotalCount = sum(Count))
    })

    # Plot histogram of total counts, gray in background
    plot(heights$Length,
         heights$TotalCount,
         type = "h",
         xlim = xlim,
         ylim = ylim,
         main = main,
         col = col.unlabeled,
         xlab = "Length (nt)",
         ylab = "Sequence Count",
         lwd = lwd,
         lend = 1)

    # Stack counts for individual sequences for the locus-labeled cases.  If any
    # rows match specific conditions, color those rectangles separately.
    for (len in unique(samp$Length)) {
      idx <- with(samp, Length == len & MatchingLocus != "")
      chunk <- samp[idx, ]
      if (nrow(chunk) < 1)
        next
      chunk <- chunk[order(chunk$Count), ]
      chunk$Cumsum <- cumsum(chunk$Count)
      for (n in 1:nrow(chunk)) {
        x <- c(len - lwd / 10,
               len - lwd / 10,
               len + lwd / 10,
               len + lwd / 10)
        y <- c(chunk[n, "Cumsum"] - chunk[n, "Count"],
               chunk[n, "Cumsum"],
               chunk[n, "Cumsum"],
               chunk[n, "Cumsum"] - chunk[n, "Count"])
        # Is the sequence matching all criteria for a candidate allele?
        allele_match <- allele.match(chunk[n, ], locus.name)
        if(is.na(allele_match)) allele_match <- F
        # Is the sequence an exact match for an identified allele?
        is_allele <- chunk[n, 'Seq'] %in%
          as.character(unlist(sample.summary[c('Allele1Seq', 'Allele2Seq')]))
        # Color each rectangle according to its category as defined by the
        # above.  The default will be the locus-labeled colors.
        col <- col.labeled
        col.border <- border.labled
        if (is_allele) {
          col <- col.allele
          col.border <- border.allele
        } else if (allele_match) {
          col <- col.filtered
          col.border <- border.filtered
        }
        polygon(x, y, col = col, border = col.border, lwd=0.5)
      }
    }
  }
}

# if include.blanks = TRUE then we should have a full count of all alleles when
# adding up the numbers on the extra axis labels.
plot.alignment <- function(alignment, labels=NULL, include.blanks=FALSE, ...) {
  # Convert to character and remove blanks if specified
  if (is.character(alignment))
    seqs <- alignment
  else
    seqs <- as.character(alignment)
  if (! include.blanks)
    seqs <- seqs[grep('^-+$', seqs, invert = TRUE)]
  # Create grouping factor using sequence length (just strip out the gap
  # character to get the original length back).
  groups <- factor(paste('  ', nchar(gsub('-', '', seqs)), 'bp'))
  par(mar = c(5, 5, 4, 5))
  dnaplotr::plotDNA(seqs,
                    groups = groups,
                    ...)
  # Add faint lines between all sequences
  for(i in seq_along(seqs))
    abline(h=i+0.5, col=rgb(0.5, 0.5, 0.5, 0.5))
  # Add a label for every unique sequence, using the names of the supplied
  # sequences
  if (missing(labels))
    labels <- sapply(strsplit(names(seqs), '_'), '[', 2)
  axis(4,
       at = 1:length(seqs),
       labels = labels,
       tick = F,
       padj = -2.5,
       cex.axis=0.6)
}

# Distance Matrices -------------------------------------------------------


# A skewed 0 -> 1 scale for color-coding distance tables
make.dist_scale <- function(n) {
  ((0:n)/n)**(1/3)
}

plot.dist_mat <- function(dist_mat, num.alleles=max(dist_mat),
                          dist.display_thresh=round(num.alleles*2/3),
                          ...) {
  labels <- matrix(character(length(dist_mat)), nrow=nrow(dist_mat))
  idx <- dist_mat <= dist.display_thresh
  labels[idx] <- dist_mat[idx]
  diag(labels) <- ''
  dist_scale <- make.dist_scale(num.alleles)
  color <- rgb(red=1, green=dist_scale, blue=dist_scale)

  vals <- dist_mat
  pheatmap::pheatmap(vals,
           color = color,
           display_numbers = labels,
           treeheight_row = 0,
           breaks = 0:num.alleles,
           clustering_distance_rows = as.dist(dist_mat),
           clustering_distance_cols = as.dist(dist_mat),
           ...)
}


# Heatmaps ----------------------------------------------------------------

#' Render heatmap of STR attribute across samples and loci
#'
#' Given a cross-sample summary data frame as produced by \code{analyze.dataset}
#' and the name of a column (e.g., Stutter, Homozygous, ProminentSequences),
#' plot a heatmap of the values for that attribute, with sample identifiers on
#' rows and loci on columns.  The attribute will be coerced to numeric.
#'
#' @param results_summary cross-sample summary data frame as produced by
#'   \code{analyze.dataset}.
#' @param attribute character name of column in results_summary to use.
#' @param label.by vector of column names to use when writing the genotype
#'   summary values on top of the heatmap cells (default: allele lengths).
#' @param color vector of colors passed to \code{pheatmap}.
#' @param breaks vector of breakpoints passed to \code{pheatmap}.
#' @param ... additional arguments to \code{pheatmap}.
#'
#' @export
plot.heatmap <- function(results_summary,
                         attribute,
                         label.by = c('Allele1Length', 'Allele2Length'),
                         color=c("white", "pink"),
                         breaks=NA,
                         ...) {
  tbl <- summarize.attribute(results_summary, attribute)
  data <- tbl[, -(1:2)] + 0
  tbl.labels <- summarize.genotypes(results_summary, vars = label.by)
  labels <- tbl.labels[, -(1:2)]
  data[is.na(labels)] <- NA
  labels[is.na(labels)] <- ''

  if (min(data,na.rm=T) == max(data, na.rm=T))
    breaks <- c(max(data))
  pheatmap::pheatmap(data,
                     cluster_rows = F,
                     cluster_cols = F,
                     display_numbers = labels,
                     breaks = breaks,
                     color = color,
                     ...)
}

#' Plot heatmap of suspected PCR stutter
#'
#' Given a cross-sample summary data frame as produced by
#' \code{analyze.dataset}, plot a heatmap showing which samples had alleles
#' ignored due to suspected PCR stutter, with sample identifiers on rows and
#' loci on columns.
#'
#' @param results_summary cross-sample summary data frame as produced by
#'   \code{analyze.dataset}.
#' @param ... additional arguments passed to \code{plot.heatmap}.
#'
#' @export
plot.heatmap.stutter <- function(results_summary, ...) {
  plot.heatmap(results_summary,
               "Stutter",
               legend = FALSE,
               ...)
}

#' Plot heatmap of homozygous samples
#'
#' Given a cross-sample summary data frame as produced by
#' \code{analyze.dataset}, plot a heatmap showing which samples appear
#' homozygous, with sample identifiers on rows and loci on columns.
#'
#' @param results_summary cross-sample summary data frame as produced by
#'   \code{analyze.dataset}.
#' @param ... additional arguments passed to \code{plot.heatmap}.
#'
#' @export
plot.heatmap.homozygous <- function(results_summary, ...) {
  plot.heatmap(results_summary,
               "Homozygous",
               legend = FALSE,
               ...)
}

#' Plot heatmap of samples with multiple prominent sequences
#'
#' Given a cross-sample summary data frame as produced by
#' \code{analyze.dataset}, plot a heatmap showing samples with more than two
#' prominent sequences in their analysis output, with sample identifiers on rows
#' and loci on columns.
#'
#' @param results_summary cross-sample summary data frame as produced by
#'   \code{analyze.dataset}.
#' @param ... additional arguments passed to \code{plot.heatmap}.
#'
#' @export
plot.heatmap.prominent_seqs <- function(results_summary, ...) {
  # Create a color ramp going from white for 0, 1, or 2 prominent seqs, and
  # shades of red for higher numbers.
  color_func <- colorRampPalette(c("white", "red"))
  ps <- results_summary[!is.na(results_summary$Allele1Seq), "ProminentSeqs"]
  # Deep red will only be used if somehow there are a whole lot of extra
  # sequences (say, 8); otherwise it should just go up to a pink color.
  colors <- color_func(max(8, max(ps)+1))
  # Stay white for 0 - 2
  colors[1:3] <- rep(colors[1], 3)
  # Truncate to actual number of peaks
  colors <- colors[1:max(ps) + 1]
  plot.heatmap(results_summary,
               "ProminentSeqs",
               color = colors,
               breaks = 0:(length(colors)),
               ...)
}

#' Plot heatmap of proportion of allele sequence counts
#'
#' Given a cross-sample summary data frame as produced by
#' \code{analyze.dataset}, plot a heatmap showing the proportion of matching
#' sequences for the identified alleles versus all matching sequences, with
#' sample identifiers on rows and loci on columns.
#'
#' @param results_summary cross-sample summary data frame as produced by
#'   \code{analyze.dataset}.
#' @param ... additional arguments passed to \code{plot.heatmap}.
#'
#' @export
plot.heatmap.proportions <- function(results_summary, ...) {
  cts <- results_summary[, c('Allele1Count', 'Allele2Count')]
  prop.counted <- rowSums(cts, na.rm=T)/results_summary$CountLocus
  results_summary$ProportionCounted <- prop.counted
  color_func <- colorRampPalette(c("red", "white"))
  breaks <- seq(0, 1, 0.001)
  colors <- color_func(length(breaks) - 1)
  plot.heatmap(results_summary,
               'ProportionCounted',
               color = colors,
               breaks = breaks,
               ...)
}
