# Handle report generation and plotting.  No real processing should happen here.

# Tables ------------------------------------------------------------------

#' Create genotype summary table
#'
#' Report the genotypes present in a processed dataset, converting sequences to
#' short names with optional custom naming.  If custom names are not given or
#' names for sequences are not present in the custom names, a name is
#' autogenerated from the sequence length and a truncated hash.
#'
#' @param tbl data frame as produced by \code{summarize_genotypes}.
#' @param allele.names optional data frame of custom allele names.  If present
#'   the columns "Seq" and "Name" will be used to map exact sequences to custom
#'   names.
#' @param hash.len number of characters of the sequence has to include when
#'   auto-generating allele names.  If set to zero the hash suffix is not
#'   included.
#' @param na.replicates text to replace NA entries with for the Replicates
#'     column.
#'
#' @return data frame showing summary of genotypes.
#'
#' @export
report_genotypes <- function(tbl,
                             allele.names=NULL,
                             hash.len=6,
                             na.replicates="") {
  # At this point there are columns for sample, replicate, and then the loci.
  # Name each entry in the table with either a custom or auto-generated short
  # name.
  for (j in 3:ncol(tbl)) {
    for (i in 1:nrow(tbl)) {
      if (is.na(tbl[i, j]))
        next
      row <- match(tbl[i, j], allele.names[, "Seq"])
      n <- as.character(allele.names[row, "Name"])
      if (is.na(n) || length(n) == 0)
        n <- make_allele_name(tbl[i, j], hash.len)
      tbl[i, j] <- n
    }
  }
  # If we have no replicates drop that column
  if (all(is.na(tbl$Replicate)))
    tbl <- tbl[, -2]
  else
    tbl$Replicate[is.na(tbl$Replicate)] <- na.replicates
  # Blank out any remaining NA values
  tbl[is.na(tbl)] <- ""
  tbl
}

report_idents <- function(results, closest, hash.len) {
  tbl <- summarize_genotypes(results$summary)
  tbl.known <- summarize_genotypes_known(results$genotypes.known, tbl)
  # Now tbl.closest contains a full genotype table of those entries (possibly
  # multiple per sample) that are closest to each sample.  Next, interleave with
  # the samples themselves and group each set in a report table.
  tbl.closest <- do.call(rbind, lapply(names(closest), function(nm) {
    if (length(closest[[nm]]) == 0)
      return(NULL)
    cbind(tbl.known[names(closest[[nm]]), ],
          Distance = closest[[nm]],
          Reference = nm)
  }))
  # I should clean up these functions to avoid this sort of mess.
  tbl.closest$Name <- tbl.closest$Sample
  tbl.closest$Sample <- sapply(strsplit(as.character(tbl.closest$Reference),
                                        "-"),
                             "[", 1)
  tbl.closest$Replicate <- sapply(strsplit(as.character(tbl.closest$Reference),
                                           "-"),
                                  "[", 2)
  # Remove reference column
  tbl.closest <- tbl.closest[, -match("Reference", colnames(tbl.closest))]
  rownames(tbl.closest) <- make_rownames(tbl.closest)

  tbl.ident <- report_genotypes(tbl.closest[, -match(c("Distance", "Name"),
                                                     colnames(tbl.closest))],
                                hash.len = hash.len)
  tbl.ident <- cbind(tbl.ident, tbl.closest[, c("Distance", "Name")])

  tbl.obs <- report_genotypes(tbl, hash.len = hash.len)

  # Set common columns and combine tables
  tbl.obs$Distance <- NA
  tbl.obs$Name <- ""
  tbl.combo <- rbind(tbl.obs, tbl.ident)

  # Order by sample by distance, with observations first, before known genotypes
  tbl.combo$Distance[is.na(tbl.combo$Distance)] <- ""
  tbl.combo <- tbl.combo[order_entries(tbl.combo), ]

  return(tbl.combo)
}

# Plots -------------------------------------------------------------------

#' Plot basic histogram of STR sample
#'
#' Given a processed STR sample, plot a histogram of counts per sequence length.
#'
#' @param samp data frame of dereplicated sequences.
#' @param main title of the plot.
#' @param locus.name name of the locus to match alleles for.  If unspecified the
#'   locus with the highest matched counts will be used.
#' @param sample.summary summary data frame as prepared by
#'   \code{summarize_sample}
#' @param cutoff_fraction numeric threshold for the fraction of locus-matching
#'   counts needed to call an allele.
#' @param xlim numeric range for x-axis.
#'
#' @export
#' @importFrom magrittr "%>%"
histogram <- function(samp,
                      main="Number of Reads by Sequence Length",
                      locus.name=NULL,
                      sample.summary=NULL,
                      cutoff_fraction=0.05,
                      xlim=range(samp$Length)) {

  ## Define colors and other plot parameters
  # The non-locus sequences
  col.unlabeled   <- "#000000"
  # Locus-labeled and matching all allele conditions
  col.filtered    <- "#FFAAAA"
  # Sequences matching alleles in sample.summary
  col.allele      <- "#FF0000"
  # Line showing threshold for allele calls
  col.cutoff <- grDevices::rgb(0, 0, 0, 0.5)
  # Shaded region for filtered sequences
  col.region <- grDevices::rgb(0, 0, 0, 30, maxColorValue = 255)
  lwd <- 5

  ## If there were no sequences at all, don't bother plotting.
  if (nrow(samp) == 0)
    return(NULL)

  ## Group sequences by length
  heights <- with(samp, {
    samp %>%
    dplyr::group_by(Length) %>%
    dplyr::summarize(TotalCount = sum(Count))
  })
  ymax <- max(heights$TotalCount)

  # Plot bars for all counts
  xlim <- range(heights$Length)
  ylim <- range(heights$TotalCount)
  graphics::plot(heights$Length,
       heights$TotalCount,
       type = "h",
       xlim = xlim,
       ylim = ylim,
       main = main,
       col = col.unlabeled,
       xlab = "Length (nt)",
       ylab = "Sequence Count",
       lwd = lwd,
       lend = 1)

  # If no locus name was given, take whatever locus showed the highest counts.
  if (missing(locus.name)) {
    cts <- with(samp, {
      subset(samp, MatchingLocus != "") %>%
        dplyr::group_by(MatchingLocus) %>%
        dplyr::summarize(Count = sum(Count))
    })
    cts <- cts[order(cts$Count, decreasing = T), ]
    locus.name <- if (nrow(cts) > 1) {
      as.character(cts[[1, "MatchingLocus"]])
    } else {
      NA
    }
  }

  # Define subset of sample data that matches all locus conditions
  samp.filt <- with(samp,
                 subset(samp, MatchingLocus == locus.name &
                              MotifMatch &
                              LengthMatch))

  # Just the matching sequences, if there are any.
  if (nrow(samp.filt) > 0) {
    heights.filt <- with(samp.filt, {
      samp.filt %>%
        dplyr::group_by(Length) %>%
        dplyr::summarize(TotalCount = sum(Count))
    })
    graphics::points(heights.filt$Length,
           heights.filt$TotalCount,
           type = "h",
           col = col.filtered,
           lwd = lwd,
           lend = 1)
    # Shade the domain of the filtered data in gray
    xlim.filt <- range(samp.filt$Length)
    graphics::polygon(x = rep(xlim.filt, each = 2),
            y = c(0, ymax, ymax, 0),
            col = col.region,
            border = NA)
    # Draw a line to mark the cutoff value for what's considered a prominent
    # count
    cutoff <- cutoff_fraction * sum(samp.filt$Count)
    graphics::abline(h = cutoff, col = col.cutoff)
  }

  # Draw bars for the exact allele sequences identified
  if (!is.null(sample.summary)) {
    pts.x <- c(sample.summary$Allele1Length, sample.summary$Allele2Length)
    pts.y <- c(sample.summary$Allele1Count, sample.summary$Allele2Count)
    pts.x <- pts.x[!is.na(pts.x)]
    pts.y <- pts.y[!is.na(pts.y)]
    if (length(pts.x) > 0)
      graphics::points(pts.x,
             pts.y,
             type = "h",
             col = col.allele,
             lwd = lwd,
             lend = 1)
  }

  # Legend
  graphics::legend(x = "topright", bty = "n",
         legend = c("Original",
                    "Filtered",
                    "Called Alleles",
                    "Unique Seq. Threshold"),
         col = c(col.unlabeled, col.filtered, col.allele, col.cutoff),
         pch = c(15, 15, 15, NA),
         lty = c(NA, NA, NA, 1))
}

#' Plot advanced histogram of STR sample
#'
#' Given a processed STR sample, plot a histogram of counts per unique sequence.
#' This is a more complicated version of \code{histogram}.
#'
#' @param samp data frame of dereplicated sequences.
#' @param stacked should bars be stacked together to add up to the total count
#'   for each length?  Otherwise they will be overlaid, so each bar height only
#'   corresponds to the count for that exact sequence.
#' @param main title of the plot.
#' @param locus.name name of the locus to match alleles for.  If unspecified the
#'   locus with the highest matched counts will be used.
#' @param sample.summary summary data frame as prepared by
#'   \code{summarize_sample}
#'
#' @export
#' @importFrom magrittr "%>%"
histogram2 <- function(samp,
                      stacked=TRUE,
                      main=NULL,
                      locus.name=NULL,
                      sample.summary=NULL) {
  col.unlabeled   <- "#DDDDDD" # The non-locus sequences
  # Locus-labeled sequences
  col.labeled     <- "#999999"
  border.labled   <- "#000000"
  # Locus-labeled and matching all allele conditions
  col.filtered    <- "#FFDDDD"
  border.filtered <- "#990000"
  # Sequences matching alleles in sample.summary
  col.allele      <- "#FF0000"
  border.allele   <- "#FF0000"
  lwd <- 5

  if (missing(locus.name)) {
    cts <- with(samp, {
      subset(samp, MatchingLocus != "") %>%
        dplyr::group_by(MatchingLocus) %>%
        dplyr::summarize(Count = sum(Count))
    })
    cts <- cts[order(cts$Count, decreasing = T), ]
    locus.name <- as.character(cts[[1, "MatchingLocus"]])
  }

  # TODO:
  #   support for showing stutter
  #   locus-specific options?
  #   un-stacked version
  #      show threshold

  if (stacked) {
    if (missing(main))
      main <- "Histogram of Sequence Lengths"
    # total counts at each length
    heights <- with(samp, {
        samp %>%
        dplyr::group_by(Length) %>%
        dplyr::summarize(TotalCount = sum(Count))
      })
    # Total ranges for stacked counts
    xlim <- range(heights$Length)
    ylim <- range(heights$TotalCount)
    heights.loci <- with(samp, {
      samp %>%
      subset(MatchingLocus != "") %>%
      dplyr::group_by(Length) %>%
      dplyr::summarize(TotalCount = sum(Count))
    })

    # Plot histogram of total counts, gray in background
    graphics::plot(heights$Length,
         heights$TotalCount,
         type = "h",
         xlim = xlim,
         ylim = ylim,
         main = main,
         col = col.unlabeled,
         xlab = "Length (nt)",
         ylab = "Sequence Count",
         lwd = lwd,
         lend = 1)

    # Stack counts for individual sequences for the locus-labeled cases.  If any
    # rows match specific conditions, color those rectangles separately.
    for (len in unique(samp$Length)) {
      idx <- with(samp, Length == len & MatchingLocus != "")
      chunk <- samp[idx, ]
      if (nrow(chunk) < 1)
        next
      chunk <- chunk[order(chunk$Count), ]
      chunk$Cumsum <- cumsum(chunk$Count)
      for (n in 1:nrow(chunk)) {
        x <- c(len - lwd / 10,
               len - lwd / 10,
               len + lwd / 10,
               len + lwd / 10)
        y <- c(chunk[n, "Cumsum"] - chunk[n, "Count"],
               chunk[n, "Cumsum"],
               chunk[n, "Cumsum"],
               chunk[n, "Cumsum"] - chunk[n, "Count"])
        # Is the sequence matching all criteria for a candidate allele?
        am <- allele_match(chunk[n, ], locus.name)
        if (is.na(am)) am <- F
        # Is the sequence an exact match for an identified allele?
        is_allele <- chunk[n, "Seq"] %in%
          as.character(unlist(sample.summary[c("Allele1Seq", "Allele2Seq")]))
        # Color each rectangle according to its category as defined by the
        # above.  The default will be the locus-labeled colors.
        col <- col.labeled
        col.border <- border.labled
        if (is_allele) {
          col <- col.allele
          col.border <- border.allele
        } else if (am) {
          col <- col.filtered
          col.border <- border.filtered
        }
        graphics::polygon(x, y, col = col, border = col.border, lwd = 0.5)
      }
    }
  }
}

#' Plot Sequence Alignments
#'
#' Plot an MSA alignment object.
#'
#' @param alignment MSA alignment object as produced by
#'   \code{\link{align_alleles}}, or character vector of the corresponding
#'   sequences.
#' @param labels custom labels to draw for each entry in \code{alignment}.  By
#'   default it's assumed that \code{align_alleles} was called with
#'   \code{derep=TRUE} and sequences are labeled by number of occurrences.
#' @param include.blanks should blank sequences present in the alignment be
#'   included in the plot?  \code{FALSE} by default.  If TRUE and \code{labels}
#'   is left at the default, the extra axis labels will add up to a full count
#'   of the number of alleles observed.
#' @param ... additional arguments passed to \code{\link[dnaplotr]{plotDNA}}.
#'
#' @seealso \code{\link{align_alleles}}
#'
#' @export
plot_alignment <- function(alignment, labels=NULL, include.blanks=FALSE, ...) {
  # Convert to character and remove blanks if specified
  if (is.character(alignment))
    seqs <- alignment
  else
    seqs <- as.character(alignment)
  if (! include.blanks)
    seqs <- seqs[grep("^-+$", seqs, invert = TRUE)]
  # Create grouping factor using sequence length (just strip out the gap
  # character to get the original length back).
  groups <- factor(paste("  ", nchar(gsub("-", "", seqs)), "bp"))
  graphics::par(mar = c(5, 5, 4, 5))
  dnaplotr::plotDNA(seqs,
                    groups = groups,
                    ...)
  # Add faint lines between all sequences
  for (i in seq_along(seqs))
    graphics::abline(h = i + 0.5, col = grDevices::rgb(0.5, 0.5, 0.5, 0.5))
  # Add a label for every unique sequence, using the names of the supplied
  # sequences
  if (missing(labels))
    labels <- sapply(strsplit(names(seqs), "_"), "[", 2)
  graphics::axis(4,
       at = 1:length(seqs),
       labels = labels,
       tick = F,
       padj = -2.5,
       cex.axis = 0.6)
}

# Distance Matrices -------------------------------------------------------


# A skewed 0 -> 1 scale for color-coding distance tables
make.dist_scale <- function(n) {
  ( (0:n) / n) ** (1 / 3)
}

#' Plot Distance Matrix
#'
#' Plot a heatmap of a distance matrix.
#'
#' @param dist_mat distance matrix as produced by
#'   \code{\link{summarize_dataset}} via \code{\link{make_dist_mat}}.
#' @param num.alleles the maximum number of matching/mis-matching alleles.  Used
#'   to determine color scaling.  Defaults to the highest observed distance in
#'   the matrix.
#' @param dist.display_thresh distance value at or below which distances will be
#'   explicitly drawn on the heatmap.  Above this value only the color-coding
#'   will signify distance.
#' @param ... additional arguments passed to \code{\link[pheatmap]{pheatmap}}.
#'
#' @seealso \code{\link{make_dist_mat}}
#'
#' @export
plot_dist_mat <- function(dist_mat, num.alleles=max(dist_mat),
                          dist.display_thresh=round(num.alleles * 2 / 3),
                          ...) {
  labels <- matrix(character(length(dist_mat)), nrow = nrow(dist_mat))
  idx <- dist_mat <= dist.display_thresh
  labels[idx] <- dist_mat[idx]
  diag(labels) <- ""
  dist_scale <- make.dist_scale(num.alleles)
  color <- grDevices::rgb(red = 1, green = dist_scale, blue = dist_scale)

  # Scale font size automatically between min and max values
  fontsize <- min(16, max(4, 17 - 0.11 * nrow(dist_mat)))

  args <- list(mat = dist_mat,
               color = color,
               display_numbers = labels,
               treeheight_row = 0,
               breaks = 0:num.alleles,
               fontsize = fontsize)
  if (nrow(dist_mat) == ncol(dist_mat)) {
    args <- c(args,
              clustering_distance_rows = stats::as.dist(dist_mat),
              clustering_distance_cols = stats::as.dist(dist_mat))
  } else {
    args <- c(args,
              cluster_cols = FALSE,
              cluster_rows = FALSE)
  }

  do.call(pheatmap::pheatmap, c(args, ...))
}


# Heatmaps ----------------------------------------------------------------

#' Render heatmap of STR attribute across samples and loci
#'
#' Given a cross-sample summary data frame as produced by
#' \code{\link{analyze_dataset}} and the name of a column (e.g., Stutter,
#' Homozygous, ProminentSequences), plot a heatmap of the values for that
#' attribute, with sample identifiers on rows and loci on columns.  The
#' attribute will be coerced to numeric.
#'
#' @param results combined results list
#' @param attribute character name of column in results$summary to use.
#' @param label.by vector of column names to use when writing the genotype
#'   summary values on top of the heatmap cells.  Defaults to allele sequence
#'   lengths.
#' @param color vector of colors passed to \code{\link[pheatmap]{pheatmap}}.
#' @param breaks vector of breakpoints passed to
#'   \code{\link[pheatmap]{pheatmap}}, autocalculated by default.
#' @param ... additional arguments to \code{\link[pheatmap]{pheatmap}}.
#'
#' @export
plot_heatmap <- function(results,
                         attribute,
                         label.by = c("Allele1Length", "Allele2Length"),
                         color=c("white", "pink"),
                         breaks=NA,
                         ...) {
  tbl <- summarize_attribute(results$summary, attribute)
  data <- tbl[, - (1:2)] + 0
  tbl.labels <- summarize_genotypes(results$summary, vars = label.by)
  labels <- tbl.labels[, - (1:2)]
  data[is.na(labels)] <- NA
  labels[is.na(labels)] <- ""

  # Handle edge cases where all the values are the same and/or all NA
  if (all(is.na(data)))
    data[, ] <- 0
  if (min(data, na.rm = T) == max(data, na.rm = T))
    breaks <- range(c(0, max(data), 1))

  pheatmap::pheatmap(data,
                     cluster_rows = F,
                     cluster_cols = F,
                     display_numbers = labels,
                     breaks = breaks,
                     color = color,
                     ...)
}

#' Plot heatmap of suspected PCR stutter
#'
#' Given a cross-sample summary data frame as produced by
#' \code{\link{analyze_dataset}}, plot a heatmap showing which samples had
#' alleles ignored due to suspected PCR stutter, with sample identifiers on rows
#' and loci on columns.
#'
#' @param results combined results list
#' @param ... additional arguments passed to \code{\link{plot_heatmap}}.
#'
#' @seealso \code{\link{plot_heatmap}}
#'
#' @export
plot_heatmap_stutter <- function(results, ...) {
  plot_heatmap(results,
               "Stutter",
               legend = FALSE,
               ...)
}

#' Plot heatmap of homozygous samples
#'
#' Given a cross-sample summary data frame as produced by
#' \code{\link{analyze_dataset}}, plot a heatmap showing which samples appear
#' homozygous, with sample identifiers on rows and loci on columns.
#'
#' @param results combined results list
#' @param ... additional arguments passed to \code{\link{plot_heatmap}}.
#'
#' @seealso \code{\link{plot_heatmap}}
#'
#' @export
plot_heatmap_homozygous <- function(results, ...) {
  plot_heatmap(results,
               "Homozygous",
               legend = FALSE,
               ...)
}

#' Plot heatmap of samples with multiple prominent sequences
#'
#' Given a cross-sample summary data frame as produced by
#' \code{\link{analyze_dataset}}, plot a heatmap showing samples with more than
#' two prominent sequences in their analysis output, with sample identifiers on
#' rows and loci on columns.
#'
#' @param results combined results list
#' @param ... additional arguments passed to \code{\link{plot_heatmap}}.
#'
#' @seealso \code{\link{plot_heatmap}}
#'
#' @export
plot_heatmap_prominent_seqs <- function(results, ...) {
  # Create a color ramp going from white for 0, 1, or 2 prominent seqs, and
  # shades of red for higher numbers.
  color_func <- grDevices::colorRampPalette(c("white", "red"))
  ps <- results$summary[!is.na(results$summary$Allele1Seq), "ProminentSeqs"]
  # Deep red will only be used if somehow there are a whole lot of extra
  # sequences (say, 8); otherwise it should just go up to a pink color.
  colors <- color_func(max(8, max(ps) + 1))
  # Stay white for 0 - 2
  colors[1:3] <- rep(colors[1], 3)
  # Truncate to actual number of peaks
  colors <- colors[1:max(ps) + 1]
  plot_heatmap(results,
               "ProminentSeqs",
               color = colors,
               breaks = 0:(length(colors)),
               ...)
}

#' Plot heatmap of proportion of allele sequence counts
#'
#' Given a cross-sample summary data frame as produced by
#' \code{\link{analyze_dataset}}, plot a heatmap showing the proportion of
#' matching sequences for the identified alleles versus all matching sequences,
#' with sample identifiers on rows and loci on columns.
#'
#' @param results combined results list
#' @param ... additional arguments passed to \code{\link{plot_heatmap}}.
#'
#' @seealso \code{\link{plot_heatmap}}
#'
#' @export
plot_heatmap_proportions <- function(results, ...) {
  cts <- results$summary[, c("Allele1Count", "Allele2Count")]
  prop.counted <- rowSums(cts, na.rm = T) / results$summary$CountLocus
  results$summary$ProportionCounted <- prop.counted
  color_func <- grDevices::colorRampPalette(c("red", "white"))
  breaks <- seq(0, 1, 0.001)
  colors <- color_func(length(breaks) - 1)
  plot_heatmap(results,
               "ProportionCounted",
               color = colors,
               breaks = breaks,
               ...)
}


# Markdown ----------------------------------------------------------------

# k: existing kable-generated table
# grouping: logical vector with TRUE for rows to start groups with,
# optionally named
k_group_rows <- function(k, grouping) {
  idx <- which(grouping)
  labels <- names(grouping)[idx]
  if (is.null(labels))
    labels <- seq_along(idx)
  for (i in seq_along(idx)) {
    start_row <- idx[i]
    end_row <- idx[i + 1] - 1
    if (is.na(end_row))
      end_row <- length(grouping)
    k <- kableExtra::group_rows(k, labels[i], start_row, end_row)
  }
  k
}

k_row_spec <- function(k, idx.rows, ...) {
  for (idx in idx.rows) {
    k <- kableExtra::row_spec(k, idx, ...)
  }
  k
}

# convenience function for post-processing report_genotypes() output
kable_genotypes <- function(data, group_samples=FALSE) {
  bootstrap_options <- c("striped", "hover", "condensed")
  # Group rows by sample.  Assumes they're ordered already.
  if (group_samples) {
    grouping <- as.logical(c(1, diff(as.integer(factor(data$Sample)))))
    names(grouping) <- paste("Sample", data$Sample)
    data$Sample <- NULL
  }
  k <- knitr::kable(data, row.names = FALSE, format = "html")
  k <- kableExtra::kable_styling(k,
                                 bootstrap_options = bootstrap_options,
                                 full_width = F)
  if (group_samples)
    k <- k_group_rows(k, grouping)
  k
}

# Write markdown tables to standard output for report_genotypes()
rmd_kable_genotypes <- function(results, hash.len,
                                allele.names=NULL,
                                na.replicates="",
                                locus_chunks=NULL,
                                group_samples=FALSE) {
  tbl.g <- summarize_genotypes(results$summary)
  tbl <- report_genotypes(tbl.g,
                          allele.names = allele.names,
                          hash.len = hash.len,
                          na.replicates = na.replicates)
  if (!is.null(locus_chunks)) {
    prefix <- match(c("Sample", "Replicate"), colnames(tbl))
    prefix <- prefix[!is.na(prefix)]
    for (chunk_name in names(locus_chunks)) {
      locus_cols <- paste(rep(locus_chunks[[chunk_name]], each = 2),
                          c(1, 2),
                          sep = "_")
      m <- match(locus_cols, colnames(tbl))
      m <- m[!is.na(m)]
      cat(paste0("\n\n### Loci: ", chunk_name, "\n\n"))
      cat(kable_genotypes(tbl[, c(prefix, m)], group_samples = group_samples))
    }
  } else {
    cat(kable_genotypes(tbl, group_samples = group_samples))
  }
}

kable_idents <- function(tbl, closest) {
  # Remove columns that will be represented in other ways (sample/remplicate in
  # row groupings)
  idx.remove <- match(c("Sample", "Replicate"), colnames(tbl))
  idx.remove <- idx.remove[!is.na(idx.remove)]
  tbl <- tbl[, -idx.remove]

  # Create basic table
  bootstrap_options <- c("hover", "condensed")
  k <- knitr::kable(tbl, row.names = FALSE, format = "html")
  k <- kableExtra::kable_styling(k,
                                 bootstrap_options = bootstrap_options,
                                 full_width = F)

  # Group rows by sample
  obs.select <- tbl$Distance == ""
  names(obs.select) <- paste("Sample", rownames(tbl))
  k <- k_group_rows(k, obs.select)

  # Bold rows containing a single identification per sample
  # (find the original samples, and then go one farther)
  ids <- names(closest[sapply(closest, function(x) length(x) == 1)])
  idx.rows <- match(ids, rownames(tbl)) + 1
  k <- k_row_spec(k, idx.rows, bold = TRUE)

  k
}

# TODO use locus_chunks
rmd_kable_idents <- function(results, hash.len, locus_chunks=NULL) {
  tbl.combo <- report_idents(results, results$closest_matches, hash.len)
  kable_idents(tbl.combo, results$closest_matches)
}

# Make chunked heatmaps for the counts-per-locus table.
# max.rows: maximum number of rows in a given chunked heatmap
rmd_plot_cts_per_locus <- function(results,
                                   max.rows=30,
                                   heading_prefix="###") {
  tbl <- results$cts_per_locus
  # Switch to log scale
  tbl[tbl == 0] <- NA
  tbl <- log10(tbl)
  # Count samples per locus, for breaking big heatmaps into smaller chunks but
  # not splitting loci
  tbl.loci <- table(droplevels(results$summary$Locus))
  tbl.loci <- tbl.loci[match(rownames(results$locus_attrs),
                             names(tbl.loci))]
  tbl.loci <- tbl.loci[!is.na(tbl.loci)]
  # Break loci into chunks to keep heatmap sizes reasonable
  loci.chunked <- split(names(tbl.loci),
                        floor(cumsum(tbl.loci) / max.rows))
  # Break on powers of ten (since we already log10'd above)
  breaks <- 0:ceiling(max(tbl, na.rm = T))
  color <- viridis::viridis(max(breaks))
  # Draw each heatmap across chunks of loci.  Written to assume there will be
  # multiple but this should work fine even if there's only one.
  for (loci in loci.chunked) {
    idx <- results$summary$Locus %in% loci
    idx.row <- rownames(results$summary)[idx]
    heading <- if (length(loci) > 1) {
      paste("Samples for Loci", loci[1], "-", loci[length(loci)])
    } else {
      paste("Samples for Locus", loci[1])
    }
    if (length(loci.chunked) > 1)
      cat(paste0("\n\n", heading_prefix, " ", heading, "\n\n"))
    pheatmap::pheatmap(tbl[rownames(tbl) %in% idx.row, ],
                       cluster_rows = F,
                       cluster_cols = F,
                       gaps_col = c(1, 2),
                       color = color,
                       breaks = breaks)
  }
}

# Insert image links to pre-rendered alignment images.
rmd_alignments <- function(results, heading_prefix="###") {
  invisible(lapply(names(results$alignments), function(loc) {
    cat(paste0("\n\n", heading_prefix, " Locus ", loc, "\n\n"))
    if (is.null(results$alignments[[loc]])) {
      cat(paste0("No sequences to align for Locus ", loc, "."))
      return()
    }
    fp <- file.path(results$config$dp.output,
                    results$config$dp.output.alignment_images,
                    paste0(loc, ".png"))
    cat(paste0("![](", fp, ")"))
  }))
}
